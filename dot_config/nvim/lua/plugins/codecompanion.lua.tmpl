return {
  "olimorris/codecompanion.nvim",
  opts = {
    -- opts = {
      -- log_level = "TRACE", -- or "DEBUG"
    -- },
    display = {
      chat = {
        show_token_count = true,
        show_settings = false,
      },
    },
    interactions = {
      chat = {
        {{- if eq .profile "axon-work-computer" }}
        adapter = "openai_work",
        {{- else }}
        adapter = "anthropic",
        {{- end }}
      },
      inline = {
        {{- if eq .profile "axon-work-computer" }}
        adapter = "openai_work",
        {{- else }}
        adapter = "anthropic",
        {{- end }}
      },
    },

    adapters = {
      opts = {
        cmd_timeout = 60000, -- 60 seconds, timeout for thing slike `cmd:op read ...`
      },
      http = {
        anthropic = function()
          return require("codecompanion.adapters").extend("anthropic", {
            env = {
              api_key = "cmd:op read 'op://personal/Anthropic - key-1/credential' --no-newline",
            },
            schema = {
              model = {
                choices = {
                  ["claude-opus-4-5-20251101"] = {
                    formatted_name = "Claude Opus 4.5",
                    opts = { can_reason = true, has_vision = true },
                  },
                },
                default = "claude-opus-4-5-20251101",
              },
            },
          })
        end,

        openai_personal = function()
          return require("codecompanion.adapters").extend("openai", {
            env = {
              api_key = "cmd:op read 'op://personal/OpenAI - key-1/credential' --no-newline",
            },
            schema = {
              model = {
                choices = {
                  ["gpt-5.1"] = {
                    formatted_name = "GPT 5.1",
                    opts = { can_reason = true, has_vision = true },
                  },
                },
                default = "gpt-5.1",
              },
            },
          })
        end,

        openai_work = function()
          return require("codecompanion.adapters").extend("openai", {
            env = {
              api_key = "cmd:op read 'op://personal/OpenAI - Axon - 2025-06-19/credential' --no-newline",
            },
            schema = {
              model = {
                choices = {
                  ["gpt-5.1"] = {
                    formatted_name = "GPT 5.1",
                    opts = { can_reason = true, has_vision = true },
                  },
                },
                default = "gpt-5.1",
              },
            },
          })
        end,
      },

      acp = {
        -- Existing Claude Code ACP adapter
        claude_code_acct1 = function()
          return require("codecompanion.adapters").extend("claude_code", {
            env = {
              CLAUDE_CODE_OAUTH_TOKEN = "cmd:op read 'op://personal/Anthropic - Claude - 1/oauth token' --no-newline",
            },

            defaults = {
              -- Give the ACP server some time to initialize on first request.
              timeout = 60000, -- 60 seconds
            },
          })
        end,

        claude_code_acct2 = function()
          return require("codecompanion.adapters").extend("claude_code", {
            env = {
              CLAUDE_CODE_OAUTH_TOKEN = "cmd:op read 'op://personal/Anthropic - Claude - 2/oauth token' --no-newline",
            },

            defaults = {
              -- Give the ACP server some time to initialize on first request.
              timeout = 60000, -- 60 seconds
            },
          })
        end,

        -- NEW: Mistral Vibe ACP adapter (uses `vibe-acp`)
        --
        -- Mistral documents that Vibe includes a `vibe-acp` tool for ACP-capable editors :contentReference[oaicite:5]{index=5}
        -- and that you may need to provide MISTRAL_API_KEY via env depending on your setup :contentReference[oaicite:6]{index=6}.
        mistral_vibe = function()
          -- We extend an existing ACP preset purely to inherit the ACP plumbing.
          -- Any ACP-capable agent should work as long as the launched process speaks ACP.
          -- (CodeCompanion exposes ACP adapter customization via `commands`, `defaults`, and `env`) :contentReference[oaicite:7]{index=7}
          return require("codecompanion.adapters").extend("opencode", {
            name = "mistral_vibe",
            formatted_name = "Mistral Vibe",

            commands = {
              -- Standard ACP server
              default = { "vibe-acp" },
            },

            defaults = {
              -- Give the ACP server some time to initialize on first request.
              -- (Gemini CLI example shows a timeout knob; same mechanism applies to ACP adapters) :contentReference[oaicite:9]{index=9}
              timeout = 60000, -- 60 seconds
            },

            env = {
              -- Option A (recommended with your setup style): pull from 1Password
              -- Replace the item path to match your vault naming.
              MISTRAL_API_KEY = "cmd:op read 'op://personal/mistral - AI Studio/api-key' --no-newline",
            },
          })
        end,
      },
    },

    extensions = {
      mcphub = {
        callback = "mcphub.extensions.codecompanion",
        opts = {
          show_result_in_chat = true,
          make_vars = true,
          make_slash_commands = true,
        },
      },
      history = {
        enabled = true,
        opts = {
          keymap = "gh",
          save_chat_keymap = "sc",
          auto_save = true,
          expiration_days = 0,
          picker = "fzf-lua",
          chat_filter = nil,
          picker_keymaps = {
            rename = { n = "r", i = "<M-r>" },
            delete = { n = "d", i = "<M-d>" },
            duplicate = { n = "<C-y>", i = "<C-y>" },
          },
          auto_generate_title = true,
          title_generation_opts = {
            adapter = nil,
            model = nil,
            refresh_every_n_prompts = 0,
            max_refreshes = 3,
            format_title = function(original_title)
              return original_title
            end,
          },
          continue_last_chat = false,
          delete_on_clearing_chat = false,
          dir_to_save = vim.fn.stdpath("data") .. "/codecompanion-history",
          enable_logging = false,

          summary = {
            create_summary_keymap = "gcs",
            browse_summaries_keymap = "gbs",
            generation_opts = {
              adapter = nil,
              model = nil,
              context_size = 90000,
              include_references = true,
              include_tool_outputs = true,
              system_prompt = nil,
              format_summary = nil,
            },
          },

          memory = {
            auto_create_memories_on_summary_generation = true,
            vectorcode_exe = "vectorcode",
            tool_opts = {
              default_num = 10,
            },
            notify = true,
            index_on_startup = false,
          },
        },
      },
      spinner = {},
      vectorcode = {
        ---@type VectorCode.CodeCompanion.ExtensionOpts
        opts = {
          tool_group = {
            enabled = true,
            extras = {},
            collapse = false,
          },
          tool_opts = {
            ["*"] = {},
            ls = {},
            vectorise = {},
            query = {
              max_num = { chunk = -1, document = -1 },
              default_num = { chunk = 50, document = 10 },
              include_stderr = false,
              use_lsp = false,
              no_duplicate = true,
              chunk_mode = false,
              summarise = {
                enabled = false,
                adapter = nil,
                query_augmented = true,
              },
            },
            files_ls = {},
            files_rm = {},
          },
        },
      },
    },

    prompt_library = {
      markdown = {
        dirs = {
          vim.fn.stdpath("config") .. "/prompts",
        },
      },
    },
  },

  dependencies = {
    "nvim-lua/plenary.nvim",
    "nvim-treesitter/nvim-treesitter",
    "ravitemer/mcphub.nvim",
    "ravitemer/codecompanion-history.nvim",
    "folke/noice.nvim",
    "franco-ruggeri/codecompanion-spinner.nvim",
  },

  keys = {
    { "<leader>zcaa1", mode = { "n" }, "<cmd>CodeCompanionChat<cr>", desc = "Code Companion Chat (Default Model)" },
    { "<leader>zcaa2", mode = { "n" }, "<cmd>CodeCompanionChat adapter=claude_code_acct1<cr>", desc = "Code Companion Chat (Claude Code) with carmichael1197@gmail.com" },
    { "<leader>zcaa3", mode = { "n" }, "<cmd>CodeCompanionChat adapter=claude_code_acct2<cr>", desc = "Code Companion Chat (Claude Code) with cartwmic@gmail.com" },

    -- NEW: Mistral Vibe (ACP)
    { "<leader>zcaa4", mode = { "n" }, "<cmd>CodeCompanionChat adapter=mistral_vibe<cr>", desc = "Code Companion Chat (Mistral Vibe)" },

    { "<leader>zcaaa", mode = { "n" }, "<cmd>CodeCompanionActions<cr>", desc = "Code Companion Actions" },
  },

  init = function()
    require("plugins.codecompanion.companion-notification").init()
  end,
}


